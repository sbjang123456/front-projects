"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "../../.yarn/__virtual__/@tanstack-react-virtual-virtual-72085275ad/0/cache/@tanstack-react-virtual-npm-3.5.1-38e9baa126-11c8e9e239.zip/node_modules/@tanstack/react-virtual/dist/esm/index.js":
/*!*****************************************************************************************************************************************************************************************************!*\
  !*** ../../.yarn/__virtual__/@tanstack-react-virtual-virtual-72085275ad/0/cache/@tanstack-react-virtual-npm-3.5.1-38e9baa126-11c8e9e239.zip/node_modules/@tanstack/react-virtual/dist/esm/index.js ***!
  \*****************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useVirtualizer: () => (/* binding */ useVirtualizer),\n/* harmony export */   useWindowVirtualizer: () => (/* binding */ useWindowVirtualizer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"react-dom\");\n/* harmony import */ var _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/virtual-core */ \"../../.yarn/cache/@tanstack-virtual-core-npm-3.5.1-70eec2c077-90f3a316c5.zip/node_modules/@tanstack/virtual-core/dist/esm/index.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"useVirtualizer\",\"useWindowVirtualizer\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useVirtualizerBase(options) {\n  const rerender = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(() => ({}), {})[1];\n  const resolvedOptions = {\n    ...options,\n    onChange: (instance2, sync) => {\n      var _a;\n      if (sync) {\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(rerender);\n      } else {\n        rerender();\n      }\n      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n    }\n  };\n  const [instance] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => new _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer(resolvedOptions)\n  );\n  instance.setOptions(resolvedOptions);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return instance._didMount();\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate();\n  });\n  return instance;\n}\nfunction useVirtualizer(options) {\n  return useVirtualizerBase({\n    observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect,\n    observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset,\n    scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll,\n    ...options\n  });\n}\nfunction useWindowVirtualizer(options) {\n  return useVirtualizerBase({\n    getScrollElement: () => typeof document !== \"undefined\" ? window : null,\n    observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect,\n    observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset,\n    scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll,\n    initialOffset: () => typeof document !== \"undefined\" ? window.scrollY : 0,\n    ...options\n  });\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vQHRhbnN0YWNrLXJlYWN0LXZpcnR1YWwtdmlydHVhbC03MjA4NTI3NWFkLzAvY2FjaGUvQHRhbnN0YWNrLXJlYWN0LXZpcnR1YWwtbnBtLTMuNS4xLTM4ZTliYWExMjYtMTFjOGU5ZTIzOS56aXAvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9yZWFjdC12aXJ0dWFsL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStCO0FBQ087QUFDOEg7QUFDN0g7QUFDdkMsb0VBQW9FLGtEQUFxQixHQUFHLDRDQUFlO0FBQzNHO0FBQ0EsbUJBQW1CLDZDQUFnQixVQUFVLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVM7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQWM7QUFDbkMsY0FBYywrREFBVztBQUN6QjtBQUNBO0FBQ0EsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4QixnQkFBZ0IsaUVBQWE7QUFDN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUVBQWlCO0FBQ3pDLDBCQUEwQix1RUFBbUI7QUFDN0MsZ0JBQWdCLGdFQUFZO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNiamFuZy9kb2NzLy4uLy4uLy55YXJuL19fdmlydHVhbF9fL0B0YW5zdGFjay1yZWFjdC12aXJ0dWFsLXZpcnR1YWwtNzIwODUyNzVhZC8wL2NhY2hlL0B0YW5zdGFjay1yZWFjdC12aXJ0dWFsLW5wbS0zLjUuMS0zOGU5YmFhMTI2LTExYzhlOWUyMzkuemlwL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdmlydHVhbC9kaXN0L2VzbS9pbmRleC5qcz9jMjZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgb2JzZXJ2ZUVsZW1lbnRSZWN0LCBvYnNlcnZlRWxlbWVudE9mZnNldCwgZWxlbWVudFNjcm9sbCwgb2JzZXJ2ZVdpbmRvd1JlY3QsIG9ic2VydmVXaW5kb3dPZmZzZXQsIHdpbmRvd1Njcm9sbCwgVmlydHVhbGl6ZXIgfSBmcm9tIFwiQHRhbnN0YWNrL3ZpcnR1YWwtY29yZVwiO1xuZXhwb3J0ICogZnJvbSBcIkB0YW5zdGFjay92aXJ0dWFsLWNvcmVcIjtcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VWaXJ0dWFsaXplckJhc2Uob3B0aW9ucykge1xuICBjb25zdCByZXJlbmRlciA9IFJlYWN0LnVzZVJlZHVjZXIoKCkgPT4gKHt9KSwge30pWzFdO1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBvbkNoYW5nZTogKGluc3RhbmNlMiwgc3luYykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgZmx1c2hTeW5jKHJlcmVuZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcmVuZGVyKCk7XG4gICAgICB9XG4gICAgICAoX2EgPSBvcHRpb25zLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBpbnN0YW5jZTIsIHN5bmMpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgW2luc3RhbmNlXSA9IFJlYWN0LnVzZVN0YXRlKFxuICAgICgpID0+IG5ldyBWaXJ0dWFsaXplcihyZXNvbHZlZE9wdGlvbnMpXG4gICk7XG4gIGluc3RhbmNlLnNldE9wdGlvbnMocmVzb2x2ZWRPcHRpb25zKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2RpZE1vdW50KCk7XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl93aWxsVXBkYXRlKCk7XG4gIH0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiB1c2VWaXJ0dWFsaXplcihvcHRpb25zKSB7XG4gIHJldHVybiB1c2VWaXJ0dWFsaXplckJhc2Uoe1xuICAgIG9ic2VydmVFbGVtZW50UmVjdCxcbiAgICBvYnNlcnZlRWxlbWVudE9mZnNldCxcbiAgICBzY3JvbGxUb0ZuOiBlbGVtZW50U2Nyb2xsLFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VXaW5kb3dWaXJ0dWFsaXplcihvcHRpb25zKSB7XG4gIHJldHVybiB1c2VWaXJ0dWFsaXplckJhc2Uoe1xuICAgIGdldFNjcm9sbEVsZW1lbnQ6ICgpID0+IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IG51bGwsXG4gICAgb2JzZXJ2ZUVsZW1lbnRSZWN0OiBvYnNlcnZlV2luZG93UmVjdCxcbiAgICBvYnNlcnZlRWxlbWVudE9mZnNldDogb2JzZXJ2ZVdpbmRvd09mZnNldCxcbiAgICBzY3JvbGxUb0ZuOiB3aW5kb3dTY3JvbGwsXG4gICAgaW5pdGlhbE9mZnNldDogKCkgPT4gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnNjcm9sbFkgOiAwLFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG59XG5leHBvcnQge1xuICB1c2VWaXJ0dWFsaXplcixcbiAgdXNlV2luZG93VmlydHVhbGl6ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../.yarn/__virtual__/@tanstack-react-virtual-virtual-72085275ad/0/cache/@tanstack-react-virtual-npm-3.5.1-38e9baa126-11c8e9e239.zip/node_modules/@tanstack/react-virtual/dist/esm/index.js\n");

/***/ }),

/***/ "../../.yarn/cache/@tanstack-virtual-core-npm-3.5.1-70eec2c077-90f3a316c5.zip/node_modules/@tanstack/virtual-core/dist/esm/index.js":
/*!******************************************************************************************************************************************!*\
  !*** ../../.yarn/cache/@tanstack-virtual-core-npm-3.5.1-70eec2c077-90f3a316c5.zip/node_modules/@tanstack/virtual-core/dist/esm/index.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* binding */ defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* binding */ defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* binding */ elementScroll),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* binding */ observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* binding */ observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* binding */ observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* binding */ observeWindowRect),\n/* harmony export */   windowScroll: () => (/* binding */ windowScroll)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../../.yarn/cache/@tanstack-virtual-core-npm-3.5.1-70eec2c077-90f3a316c5.zip/node_modules/@tanstack/virtual-core/dist/esm/utils.js\");\n\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(element.getBoundingClientRect());\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const entry = entries[0];\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n      const box = entry.borderBoxSize[0];\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize });\n        return;\n      }\n    }\n    handler(element.getBoundingClientRect());\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = supportsScrollend ? () => void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    element.removeEventListener(\"scrollend\", endHandler);\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = supportsScrollend ? () => void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    element.removeEventListener(\"scrollend\", endHandler);\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]\n  );\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.measureElementCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            this._measureElement(entry.target, entry);\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.disconnect();\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\")\n          delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        ...opts2\n      };\n    };\n    this.notify = (force, sync) => {\n      var _a, _b;\n      const { startIndex, endIndex } = this.range ?? {\n        startIndex: void 0,\n        endIndex: void 0\n      };\n      const range = this.calculateRange();\n      if (force || startIndex !== (range == null ? void 0 : range.startIndex) || endIndex !== (range == null ? void 0 : range.endIndex)) {\n        (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n      }\n    };\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n    this._didMount = () => {\n      this.measureElementCache.forEach(this.observer.observe);\n      return () => {\n        this.observer.disconnect();\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.getScrollElement();\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.notify(false, false);\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.scrollOffset < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            const prevIsScrolling = this.isScrolling;\n            this.isScrolling = isScrolling;\n            this.notify(prevIsScrolling !== isScrolling, isScrolling);\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getMeasurementOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey\n      ],\n      (count, paddingStart, scrollMargin, getItemKey) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurements = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache) => {\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key:  true && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [this.getMeasurements(), this.getSize(), this.scrollOffset],\n      (measurements, outerSize, scrollOffset) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset\n        }) : null;\n      },\n      {\n        key:  true && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getIndexes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [\n        this.options.rangeExtractor,\n        this.calculateRange(),\n        this.options.overscan,\n        this.options.count\n      ],\n      (rangeExtractor, range, overscan, count) => {\n        return range === null ? [] : rangeExtractor({\n          startIndex: range.startIndex,\n          endIndex: range.endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key:  true && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const item = this.measurementsCache[this.indexFromElement(node)];\n      if (!item || !node.isConnected) {\n        this.measureElementCache.forEach((cached, key) => {\n          if (cached === node) {\n            this.observer.unobserve(node);\n            this.measureElementCache.delete(key);\n          }\n        });\n        return;\n      }\n      const prevNode = this.measureElementCache.get(item.key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.measureElementCache.set(item.key, node);\n      }\n      const measuredItemSize = this.options.measureElement(node, entry, this);\n      this.resizeItem(item, measuredItemSize);\n    };\n    this.resizeItem = (item, size) => {\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.scrollOffset + this.scrollAdjustments) {\n          if ( true && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.scrollOffset, {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(true, false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [this.getIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key:  true && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align) => {\n      const size = this.getSize();\n      if (align === \"auto\") {\n        if (toOffset <= this.scrollOffset) {\n          align = \"start\";\n        } else if (toOffset >= this.scrollOffset + size) {\n          align = \"end\";\n        } else {\n          align = \"start\";\n        }\n      }\n      if (align === \"start\") {\n        toOffset = toOffset;\n      } else if (align === \"end\") {\n        toOffset = toOffset - size;\n      } else if (align === \"center\") {\n        toOffset = toOffset - size / 2;\n      }\n      const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n      const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n      const maxOffset = scrollSize - this.getSize();\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const measurement = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(this.getMeasurements()[index]);\n      if (align === \"auto\") {\n        if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [this.scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;\n      return [this.getOffsetForAlignment(toOffset, align), align];\n    };\n    this.isDynamicMode = () => this.measureElementCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);\n      this._scrollToOffset(toOffset, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode() && this.targetWindow) {\n        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.measureElementCache.has(\n            this.options.getItemKey(index)\n          );\n          if (elementInDOM) {\n            const [toOffset2] = this.getOffsetForIndex(index, align);\n            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual)(toOffset2, this.scrollOffset)) {\n              this.scrollToIndex(index, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.scrollOffset + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else {\n        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(\n          ...measurements.slice(-this.options.lanes).map((m) => m.end)\n        );\n      }\n      return end - this.options.scrollMargin + this.options.paddingEnd;\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      var _a, _b;\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, false);\n    };\n    this.setOptions(opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset;\n    this.measurementsCache = this.options.initialMeasurementsCache;\n    this.measurementsCache.forEach((item) => {\n      this.itemSizeCache.set(item.key, item.size);\n    });\n    this.notify(false, false);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset\n}) {\n  const count = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return { startIndex, endIndex };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLnlhcm4vY2FjaGUvQHRhbnN0YWNrLXZpcnR1YWwtY29yZS1ucG0tMy41LjEtNzBlZWMyYzA3Ny05MGYzYTMxNmM1LnppcC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixTQUFTLHNEQUFzRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUE4QztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3REFBd0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1EQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbURBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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K0JBQStCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUIsMENBQTBDLGlCQUFpQjtBQUMzRDtBQUNBLFlBQVk7QUFDWix3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFnQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYmphbmcvZG9jcy8uLi8uLi8ueWFybi9jYWNoZS9AdGFuc3RhY2stdmlydHVhbC1jb3JlLW5wbS0zLjUuMS03MGVlYzJjMDc3LTkwZjNhMzE2YzUuemlwL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2Rpc3QvZXNtL2luZGV4LmpzP2UzMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVib3VuY2UsIG1lbW8sIG5vdFVuZGVmaW5lZCwgYXBwcm94RXF1YWwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuY29uc3QgZGVmYXVsdEtleUV4dHJhY3RvciA9IChpbmRleCkgPT4gaW5kZXg7XG5jb25zdCBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IgPSAocmFuZ2UpID0+IHtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChyYW5nZS5zdGFydEluZGV4IC0gcmFuZ2Uub3ZlcnNjYW4sIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihyYW5nZS5lbmRJbmRleCArIHJhbmdlLm92ZXJzY2FuLCByYW5nZS5jb3VudCAtIDEpO1xuICBjb25zdCBhcnIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgYXJyLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5jb25zdCBvYnNlcnZlRWxlbWVudFJlY3QgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0V2luZG93ID0gaW5zdGFuY2UudGFyZ2V0V2luZG93O1xuICBpZiAoIXRhcmdldFdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gKHJlY3QpID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJlY3Q7XG4gICAgY2IoeyB3aWR0aDogTWF0aC5yb3VuZCh3aWR0aCksIGhlaWdodDogTWF0aC5yb3VuZChoZWlnaHQpIH0pO1xuICB9O1xuICBoYW5kbGVyKGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICBpZiAoIXRhcmdldFdpbmRvdy5SZXNpemVPYnNlcnZlcikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvYnNlcnZlciA9IG5ldyB0YXJnZXRXaW5kb3cuUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgaWYgKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5ib3JkZXJCb3hTaXplKSB7XG4gICAgICBjb25zdCBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdO1xuICAgICAgaWYgKGJveCkge1xuICAgICAgICBoYW5kbGVyKHsgd2lkdGg6IGJveC5pbmxpbmVTaXplLCBoZWlnaHQ6IGJveC5ibG9ja1NpemUgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlcihlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwgeyBib3g6IFwiYm9yZGVyLWJveFwiIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgfTtcbn07XG5jb25zdCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcbmNvbnN0IG9ic2VydmVXaW5kb3dSZWN0ID0gKGluc3RhbmNlLCBjYikgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgY2IoeyB3aWR0aDogZWxlbWVudC5pbm5lcldpZHRoLCBoZWlnaHQ6IGVsZW1lbnQuaW5uZXJIZWlnaHQgfSk7XG4gIH07XG4gIGhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlcik7XG4gIH07XG59O1xuY29uc3Qgc3VwcG9ydHNTY3JvbGxlbmQgPSB0eXBlb2Ygd2luZG93ID09IFwidW5kZWZpbmVkXCIgPyB0cnVlIDogXCJvbnNjcm9sbGVuZFwiIGluIHdpbmRvdztcbmNvbnN0IG9ic2VydmVFbGVtZW50T2Zmc2V0ID0gKGluc3RhbmNlLCBjYikgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhcmdldFdpbmRvdyA9IGluc3RhbmNlLnRhcmdldFdpbmRvdztcbiAgaWYgKCF0YXJnZXRXaW5kb3cpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGZhbGxiYWNrID0gc3VwcG9ydHNTY3JvbGxlbmQgPyAoKSA9PiB2b2lkIDAgOiBkZWJvdW5jZShcbiAgICB0YXJnZXRXaW5kb3csXG4gICAgKCkgPT4ge1xuICAgICAgY2Iob2Zmc2V0LCBmYWxzZSk7XG4gICAgfSxcbiAgICBpbnN0YW5jZS5vcHRpb25zLmlzU2Nyb2xsaW5nUmVzZXREZWxheVxuICApO1xuICBjb25zdCBjcmVhdGVIYW5kbGVyID0gKGlzU2Nyb2xsaW5nKSA9PiAoKSA9PiB7XG4gICAgb2Zmc2V0ID0gZWxlbWVudFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcInNjcm9sbExlZnRcIiA6IFwic2Nyb2xsVG9wXCJdO1xuICAgIGZhbGxiYWNrKCk7XG4gICAgY2Iob2Zmc2V0LCBpc1Njcm9sbGluZyk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKHRydWUpO1xuICBjb25zdCBlbmRIYW5kbGVyID0gY3JlYXRlSGFuZGxlcihmYWxzZSk7XG4gIGVuZEhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIpO1xuICB9O1xufTtcbmNvbnN0IG9ic2VydmVXaW5kb3dPZmZzZXQgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0V2luZG93ID0gaW5zdGFuY2UudGFyZ2V0V2luZG93O1xuICBpZiAoIXRhcmdldFdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZmFsbGJhY2sgPSBzdXBwb3J0c1Njcm9sbGVuZCA/ICgpID0+IHZvaWQgMCA6IGRlYm91bmNlKFxuICAgIHRhcmdldFdpbmRvdyxcbiAgICAoKSA9PiB7XG4gICAgICBjYihvZmZzZXQsIGZhbHNlKTtcbiAgICB9LFxuICAgIGluc3RhbmNlLm9wdGlvbnMuaXNTY3JvbGxpbmdSZXNldERlbGF5XG4gICk7XG4gIGNvbnN0IGNyZWF0ZUhhbmRsZXIgPSAoaXNTY3JvbGxpbmcpID0+ICgpID0+IHtcbiAgICBvZmZzZXQgPSBlbGVtZW50W2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwic2Nyb2xsWFwiIDogXCJzY3JvbGxZXCJdO1xuICAgIGZhbGxiYWNrKCk7XG4gICAgY2Iob2Zmc2V0LCBpc1Njcm9sbGluZyk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKHRydWUpO1xuICBjb25zdCBlbmRIYW5kbGVyID0gY3JlYXRlSGFuZGxlcihmYWxzZSk7XG4gIGVuZEhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIpO1xuICB9O1xufTtcbmNvbnN0IG1lYXN1cmVFbGVtZW50ID0gKGVsZW1lbnQsIGVudHJ5LCBpbnN0YW5jZSkgPT4ge1xuICBpZiAoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmJvcmRlckJveFNpemUpIHtcbiAgICBjb25zdCBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdO1xuICAgIGlmIChib3gpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBNYXRoLnJvdW5kKFxuICAgICAgICBib3hbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJpbmxpbmVTaXplXCIgOiBcImJsb2NrU2l6ZVwiXVxuICAgICAgKTtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChcbiAgICBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdXG4gICk7XG59O1xuY29uc3Qgd2luZG93U2Nyb2xsID0gKG9mZnNldCwge1xuICBhZGp1c3RtZW50cyA9IDAsXG4gIGJlaGF2aW9yXG59LCBpbnN0YW5jZSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB0b09mZnNldCA9IG9mZnNldCArIGFkanVzdG1lbnRzO1xuICAoX2IgPSAoX2EgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2Nyb2xsVG8pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgW2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwibGVmdFwiIDogXCJ0b3BcIl06IHRvT2Zmc2V0LFxuICAgIGJlaGF2aW9yXG4gIH0pO1xufTtcbmNvbnN0IGVsZW1lbnRTY3JvbGwgPSAob2Zmc2V0LCB7XG4gIGFkanVzdG1lbnRzID0gMCxcbiAgYmVoYXZpb3Jcbn0sIGluc3RhbmNlKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHRvT2Zmc2V0ID0gb2Zmc2V0ICsgYWRqdXN0bWVudHM7XG4gIChfYiA9IChfYSA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY3JvbGxUbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICBbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcInRvcFwiXTogdG9PZmZzZXQsXG4gICAgYmVoYXZpb3JcbiAgfSk7XG59O1xuY2xhc3MgVmlydHVhbGl6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy51bnN1YnMgPSBbXTtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0V2luZG93ID0gbnVsbDtcbiAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gW107XG4gICAgdGhpcy5pdGVtU2l6ZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNjcm9sbEFkanVzdG1lbnRzID0gMDtcbiAgICB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICAgIGxldCBfcm8gPSBudWxsO1xuICAgICAgY29uc3QgZ2V0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoX3JvKSB7XG4gICAgICAgICAgcmV0dXJuIF9ybztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0V2luZG93IHx8ICF0aGlzLnRhcmdldFdpbmRvdy5SZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcm8gPSBuZXcgdGhpcy50YXJnZXRXaW5kb3cuUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChlbnRyeS50YXJnZXQsIGVudHJ5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4gKF9hID0gZ2V0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9ic2VydmU6ICh0YXJnZXQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIChfYSA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2Eub2JzZXJ2ZSh0YXJnZXQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5vYnNlcnZlOiAodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgdGhpcy5yYW5nZSA9IG51bGw7XG4gICAgdGhpcy5zZXRPcHRpb25zID0gKG9wdHMyKSA9PiB7XG4gICAgICBPYmplY3QuZW50cmllcyhvcHRzMikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgZGVsZXRlIG9wdHMyW2tleV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsT2Zmc2V0OiAwLFxuICAgICAgICBvdmVyc2NhbjogMSxcbiAgICAgICAgcGFkZGluZ1N0YXJ0OiAwLFxuICAgICAgICBwYWRkaW5nRW5kOiAwLFxuICAgICAgICBzY3JvbGxQYWRkaW5nU3RhcnQ6IDAsXG4gICAgICAgIHNjcm9sbFBhZGRpbmdFbmQ6IDAsXG4gICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICBnZXRJdGVtS2V5OiBkZWZhdWx0S2V5RXh0cmFjdG9yLFxuICAgICAgICByYW5nZUV4dHJhY3RvcjogZGVmYXVsdFJhbmdlRXh0cmFjdG9yLFxuICAgICAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBtZWFzdXJlRWxlbWVudCxcbiAgICAgICAgaW5pdGlhbFJlY3Q6IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LFxuICAgICAgICBzY3JvbGxNYXJnaW46IDAsXG4gICAgICAgIGdhcDogMCxcbiAgICAgICAgaW5kZXhBdHRyaWJ1dGU6IFwiZGF0YS1pbmRleFwiLFxuICAgICAgICBpbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGU6IFtdLFxuICAgICAgICBsYW5lczogMSxcbiAgICAgICAgaXNTY3JvbGxpbmdSZXNldERlbGF5OiAxNTAsXG4gICAgICAgIC4uLm9wdHMyXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5ub3RpZnkgPSAoZm9yY2UsIHN5bmMpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSB0aGlzLnJhbmdlID8/IHtcbiAgICAgICAgc3RhcnRJbmRleDogdm9pZCAwLFxuICAgICAgICBlbmRJbmRleDogdm9pZCAwXG4gICAgICB9O1xuICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZVJhbmdlKCk7XG4gICAgICBpZiAoZm9yY2UgfHwgc3RhcnRJbmRleCAhPT0gKHJhbmdlID09IG51bGwgPyB2b2lkIDAgOiByYW5nZS5zdGFydEluZGV4KSB8fCBlbmRJbmRleCAhPT0gKHJhbmdlID09IG51bGwgPyB2b2lkIDAgOiByYW5nZS5lbmRJbmRleCkpIHtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMsIHN5bmMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgdGhpcy51bnN1YnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKGQpID0+IGQoKSk7XG4gICAgICB0aGlzLnVuc3VicyA9IFtdO1xuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuX2RpZE1vdW50ID0gKCkgPT4ge1xuICAgICAgdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLmZvckVhY2godGhpcy5vYnNlcnZlci5vYnNlcnZlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLl93aWxsVXBkYXRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMub3B0aW9ucy5nZXRTY3JvbGxFbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy5zY3JvbGxFbGVtZW50ICE9PSBzY3JvbGxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxFbGVtZW50ICYmIFwib3duZXJEb2N1bWVudFwiIGluIHRoaXMuc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMudGFyZ2V0V2luZG93ID0gdGhpcy5zY3JvbGxFbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50YXJnZXRXaW5kb3cgPSAoKF9hID0gdGhpcy5zY3JvbGxFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Eud2luZG93KSA/PyBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuc2Nyb2xsT2Zmc2V0LCB7XG4gICAgICAgICAgYWRqdXN0bWVudHM6IHZvaWQgMCxcbiAgICAgICAgICBiZWhhdmlvcjogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVuc3Vicy5wdXNoKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudFJlY3QodGhpcywgKHJlY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudW5zdWJzLnB1c2goXG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9ic2VydmVFbGVtZW50T2Zmc2V0KHRoaXMsIChvZmZzZXQsIGlzU2Nyb2xsaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFkanVzdG1lbnRzID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gaXNTY3JvbGxpbmcgPyB0aGlzLnNjcm9sbE9mZnNldCA8IG9mZnNldCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgcHJldklzU2Nyb2xsaW5nID0gdGhpcy5pc1Njcm9sbGluZztcbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBpc1Njcm9sbGluZztcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KHByZXZJc1Njcm9sbGluZyAhPT0gaXNTY3JvbGxpbmcsIGlzU2Nyb2xsaW5nKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUmVjdFt0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdO1xuICAgIH07XG4gICAgdGhpcy5nZXRNZWFzdXJlbWVudE9wdGlvbnMgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnQsXG4gICAgICAgIHRoaXMub3B0aW9ucy5wYWRkaW5nU3RhcnQsXG4gICAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4sXG4gICAgICAgIHRoaXMub3B0aW9ucy5nZXRJdGVtS2V5XG4gICAgICBdLFxuICAgICAgKGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvdW50LFxuICAgICAgICAgIHBhZGRpbmdTdGFydCxcbiAgICAgICAgICBzY3JvbGxNYXJnaW4sXG4gICAgICAgICAgZ2V0SXRlbUtleVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBmYWxzZVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5nZXRGdXJ0aGVzdE1lYXN1cmVtZW50ID0gKG1lYXN1cmVtZW50cywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgZnVydGhlc3RNZWFzdXJlbWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChsZXQgbSA9IGluZGV4IC0gMTsgbSA+PSAwOyBtLS0pIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbbV07XG4gICAgICAgIGlmIChmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLmhhcyhtZWFzdXJlbWVudC5sYW5lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudCA9IGZ1cnRoZXN0TWVhc3VyZW1lbnRzLmdldChcbiAgICAgICAgICBtZWFzdXJlbWVudC5sYW5lXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQgPT0gbnVsbCB8fCBtZWFzdXJlbWVudC5lbmQgPiBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQuZW5kKSB7XG4gICAgICAgICAgZnVydGhlc3RNZWFzdXJlbWVudHMuc2V0KG1lYXN1cmVtZW50LmxhbmUsIG1lYXN1cmVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWFzdXJlbWVudC5lbmQgPCBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQuZW5kKSB7XG4gICAgICAgICAgZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5zZXQobWVhc3VyZW1lbnQubGFuZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuc2l6ZSA9PT0gdGhpcy5vcHRpb25zLmxhbmVzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdXJ0aGVzdE1lYXN1cmVtZW50cy5zaXplID09PSB0aGlzLm9wdGlvbnMubGFuZXMgPyBBcnJheS5mcm9tKGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLmVuZCA9PT0gYi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuZW5kIC0gYi5lbmQ7XG4gICAgICB9KVswXSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TWVhc3VyZW1lbnRzID0gbWVtbyhcbiAgICAgICgpID0+IFt0aGlzLmdldE1lYXN1cmVtZW50T3B0aW9ucygpLCB0aGlzLml0ZW1TaXplQ2FjaGVdLFxuICAgICAgKHsgY291bnQsIHBhZGRpbmdTdGFydCwgc2Nyb2xsTWFyZ2luLCBnZXRJdGVtS2V5IH0sIGl0ZW1TaXplQ2FjaGUpID0+IHtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMubGVuZ3RoID4gMCA/IE1hdGgubWluKC4uLnRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzKSA6IDA7XG4gICAgICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzID0gW107XG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUuc2xpY2UoMCwgbWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1pbjsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBnZXRJdGVtS2V5KGkpO1xuICAgICAgICAgIGNvbnN0IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPSB0aGlzLm9wdGlvbnMubGFuZXMgPT09IDEgPyBtZWFzdXJlbWVudHNbaSAtIDFdIDogdGhpcy5nZXRGdXJ0aGVzdE1lYXN1cmVtZW50KG1lYXN1cmVtZW50cywgaSk7XG4gICAgICAgICAgY29uc3Qgc3RhcnQgPSBmdXJ0aGVzdE1lYXN1cmVtZW50ID8gZnVydGhlc3RNZWFzdXJlbWVudC5lbmQgKyB0aGlzLm9wdGlvbnMuZ2FwIDogcGFkZGluZ1N0YXJ0ICsgc2Nyb2xsTWFyZ2luO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVkU2l6ZSA9IGl0ZW1TaXplQ2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IHR5cGVvZiBtZWFzdXJlZFNpemUgPT09IFwibnVtYmVyXCIgPyBtZWFzdXJlZFNpemUgOiB0aGlzLm9wdGlvbnMuZXN0aW1hdGVTaXplKGkpO1xuICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgc2l6ZTtcbiAgICAgICAgICBjb25zdCBsYW5lID0gZnVydGhlc3RNZWFzdXJlbWVudCA/IGZ1cnRoZXN0TWVhc3VyZW1lbnQubGFuZSA6IGkgJSB0aGlzLm9wdGlvbnMubGFuZXM7XG4gICAgICAgICAgbWVhc3VyZW1lbnRzW2ldID0ge1xuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBsYW5lXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gbWVhc3VyZW1lbnRzO1xuICAgICAgICByZXR1cm4gbWVhc3VyZW1lbnRzO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJnZXRNZWFzdXJlbWVudHNcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1Z1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5jYWxjdWxhdGVSYW5nZSA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGhpcy5nZXRNZWFzdXJlbWVudHMoKSwgdGhpcy5nZXRTaXplKCksIHRoaXMuc2Nyb2xsT2Zmc2V0XSxcbiAgICAgIChtZWFzdXJlbWVudHMsIG91dGVyU2l6ZSwgc2Nyb2xsT2Zmc2V0KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlID0gbWVhc3VyZW1lbnRzLmxlbmd0aCA+IDAgJiYgb3V0ZXJTaXplID4gMCA/IGNhbGN1bGF0ZVJhbmdlKHtcbiAgICAgICAgICBtZWFzdXJlbWVudHMsXG4gICAgICAgICAgb3V0ZXJTaXplLFxuICAgICAgICAgIHNjcm9sbE9mZnNldFxuICAgICAgICB9KSA6IG51bGw7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImNhbGN1bGF0ZVJhbmdlXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0SW5kZXhlcyA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRoaXMub3B0aW9ucy5yYW5nZUV4dHJhY3RvcixcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVSYW5nZSgpLFxuICAgICAgICB0aGlzLm9wdGlvbnMub3ZlcnNjYW4sXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb3VudFxuICAgICAgXSxcbiAgICAgIChyYW5nZUV4dHJhY3RvciwgcmFuZ2UsIG92ZXJzY2FuLCBjb3VudCkgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UgPT09IG51bGwgPyBbXSA6IHJhbmdlRXh0cmFjdG9yKHtcbiAgICAgICAgICBzdGFydEluZGV4OiByYW5nZS5zdGFydEluZGV4LFxuICAgICAgICAgIGVuZEluZGV4OiByYW5nZS5lbmRJbmRleCxcbiAgICAgICAgICBvdmVyc2NhbixcbiAgICAgICAgICBjb3VudFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0SW5kZXhlc1wiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmluZGV4RnJvbUVsZW1lbnQgPSAobm9kZSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMub3B0aW9ucy5pbmRleEF0dHJpYnV0ZTtcbiAgICAgIGNvbnN0IGluZGV4U3RyID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICBpZiAoIWluZGV4U3RyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgTWlzc2luZyBhdHRyaWJ1dGUgbmFtZSAnJHthdHRyaWJ1dGVOYW1lfT17aW5kZXh9JyBvbiBtZWFzdXJlZCBlbGVtZW50LmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlSW50KGluZGV4U3RyLCAxMCk7XG4gICAgfTtcbiAgICB0aGlzLl9tZWFzdXJlRWxlbWVudCA9IChub2RlLCBlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbdGhpcy5pbmRleEZyb21FbGVtZW50KG5vZGUpXTtcbiAgICAgIGlmICghaXRlbSB8fCAhbm9kZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuZm9yRWFjaCgoY2FjaGVkLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAoY2FjaGVkID09PSBub2RlKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnVub2JzZXJ2ZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2Tm9kZSA9IHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5nZXQoaXRlbS5rZXkpO1xuICAgICAgaWYgKHByZXZOb2RlICE9PSBub2RlKSB7XG4gICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKHByZXZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUobm9kZSk7XG4gICAgICAgIHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5zZXQoaXRlbS5rZXksIG5vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVhc3VyZWRJdGVtU2l6ZSA9IHRoaXMub3B0aW9ucy5tZWFzdXJlRWxlbWVudChub2RlLCBlbnRyeSwgdGhpcyk7XG4gICAgICB0aGlzLnJlc2l6ZUl0ZW0oaXRlbSwgbWVhc3VyZWRJdGVtU2l6ZSk7XG4gICAgfTtcbiAgICB0aGlzLnJlc2l6ZUl0ZW0gPSAoaXRlbSwgc2l6ZSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplQ2FjaGUuZ2V0KGl0ZW0ua2V5KSA/PyBpdGVtLnNpemU7XG4gICAgICBjb25zdCBkZWx0YSA9IHNpemUgLSBpdGVtU2l6ZTtcbiAgICAgIGlmIChkZWx0YSAhPT0gMCkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRBZGp1c3RTY3JvbGxQb3NpdGlvbk9uSXRlbVNpemVDaGFuZ2UgIT09IHZvaWQgMCA/IHRoaXMuc2hvdWxkQWRqdXN0U2Nyb2xsUG9zaXRpb25Pbkl0ZW1TaXplQ2hhbmdlKGl0ZW0sIGRlbHRhLCB0aGlzKSA6IGl0ZW0uc3RhcnQgPCB0aGlzLnNjcm9sbE9mZnNldCArIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiY29ycmVjdGlvblwiLCBkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuc2Nyb2xsT2Zmc2V0LCB7XG4gICAgICAgICAgICBhZGp1c3RtZW50czogdGhpcy5zY3JvbGxBZGp1c3RtZW50cyArPSBkZWx0YSxcbiAgICAgICAgICAgIGJlaGF2aW9yOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcy5wdXNoKGl0ZW0uaW5kZXgpO1xuICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSBuZXcgTWFwKHRoaXMuaXRlbVNpemVDYWNoZS5zZXQoaXRlbS5rZXksIHNpemUpKTtcbiAgICAgICAgdGhpcy5ub3RpZnkodHJ1ZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tZWFzdXJlRWxlbWVudCA9IChub2RlKSA9PiB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQobm9kZSwgdm9pZCAwKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VmlydHVhbEl0ZW1zID0gbWVtbyhcbiAgICAgICgpID0+IFt0aGlzLmdldEluZGV4ZXMoKSwgdGhpcy5nZXRNZWFzdXJlbWVudHMoKV0sXG4gICAgICAoaW5kZXhlcywgbWVhc3VyZW1lbnRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWxJdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gaW5kZXhlcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgIGNvbnN0IGkgPSBpbmRleGVzW2tdO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgICAgICAgIHZpcnR1YWxJdGVtcy5wdXNoKG1lYXN1cmVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlydHVhbEl0ZW1zO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJnZXRJbmRleGVzXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0VmlydHVhbEl0ZW1Gb3JPZmZzZXQgPSAob2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLmdldE1lYXN1cmVtZW50cygpO1xuICAgICAgcmV0dXJuIG5vdFVuZGVmaW5lZChcbiAgICAgICAgbWVhc3VyZW1lbnRzW2ZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgKGluZGV4KSA9PiBub3RVbmRlZmluZWQobWVhc3VyZW1lbnRzW2luZGV4XSkuc3RhcnQsXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgICldXG4gICAgICApO1xuICAgIH07XG4gICAgdGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQgPSAodG9PZmZzZXQsIGFsaWduKSA9PiB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBpZiAoYWxpZ24gPT09IFwiYXV0b1wiKSB7XG4gICAgICAgIGlmICh0b09mZnNldCA8PSB0aGlzLnNjcm9sbE9mZnNldCkge1xuICAgICAgICAgIGFsaWduID0gXCJzdGFydFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRvT2Zmc2V0ID49IHRoaXMuc2Nyb2xsT2Zmc2V0ICsgc2l6ZSkge1xuICAgICAgICAgIGFsaWduID0gXCJlbmRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGlnbiA9IFwic3RhcnRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFsaWduID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgdG9PZmZzZXQgPSB0b09mZnNldDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgdG9PZmZzZXQgPSB0b09mZnNldCAtIHNpemU7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgIHRvT2Zmc2V0ID0gdG9PZmZzZXQgLSBzaXplIC8gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjcm9sbFNpemVQcm9wID0gdGhpcy5vcHRpb25zLmhvcml6b250YWwgPyBcInNjcm9sbFdpZHRoXCIgOiBcInNjcm9sbEhlaWdodFwiO1xuICAgICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IHRoaXMuc2Nyb2xsRWxlbWVudCA/IFwiZG9jdW1lbnRcIiBpbiB0aGlzLnNjcm9sbEVsZW1lbnQgPyB0aGlzLnNjcm9sbEVsZW1lbnQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W3Njcm9sbFNpemVQcm9wXSA6IHRoaXMuc2Nyb2xsRWxlbWVudFtzY3JvbGxTaXplUHJvcF0gOiAwO1xuICAgICAgY29uc3QgbWF4T2Zmc2V0ID0gc2Nyb2xsU2l6ZSAtIHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKG1heE9mZnNldCwgdG9PZmZzZXQpLCAwKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXggPSAoaW5kZXgsIGFsaWduID0gXCJhdXRvXCIpID0+IHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMub3B0aW9ucy5jb3VudCAtIDEpKTtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbm90VW5kZWZpbmVkKHRoaXMuZ2V0TWVhc3VyZW1lbnRzKClbaW5kZXhdKTtcbiAgICAgIGlmIChhbGlnbiA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVtZW50LmVuZCA+PSB0aGlzLnNjcm9sbE9mZnNldCArIHRoaXMuZ2V0U2l6ZSgpIC0gdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmQpIHtcbiAgICAgICAgICBhbGlnbiA9IFwiZW5kXCI7XG4gICAgICAgIH0gZWxzZSBpZiAobWVhc3VyZW1lbnQuc3RhcnQgPD0gdGhpcy5zY3JvbGxPZmZzZXQgKyB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ1N0YXJ0KSB7XG4gICAgICAgICAgYWxpZ24gPSBcInN0YXJ0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt0aGlzLnNjcm9sbE9mZnNldCwgYWxpZ25dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0b09mZnNldCA9IGFsaWduID09PSBcImVuZFwiID8gbWVhc3VyZW1lbnQuZW5kICsgdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmQgOiBtZWFzdXJlbWVudC5zdGFydCAtIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nU3RhcnQ7XG4gICAgICByZXR1cm4gW3RoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50KHRvT2Zmc2V0LCBhbGlnbiksIGFsaWduXTtcbiAgICB9O1xuICAgIHRoaXMuaXNEeW5hbWljTW9kZSA9ICgpID0+IHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5zaXplID4gMDtcbiAgICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXggPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkICE9PSBudWxsICYmIHRoaXMudGFyZ2V0V2luZG93KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0V2luZG93LmNsZWFyVGltZW91dCh0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zY3JvbGxUb09mZnNldCA9ICh0b09mZnNldCwgeyBhbGlnbiA9IFwic3RhcnRcIiwgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXgoKTtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50KHRvT2Zmc2V0LCBhbGlnbiksIHtcbiAgICAgICAgYWRqdXN0bWVudHM6IHZvaWQgMCxcbiAgICAgICAgYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5zY3JvbGxUb0luZGV4ID0gKGluZGV4LCB7IGFsaWduOiBpbml0aWFsQWxpZ24gPSBcImF1dG9cIiwgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLm9wdGlvbnMuY291bnQgLSAxKSk7XG4gICAgICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXgoKTtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt0b09mZnNldCwgYWxpZ25dID0gdGhpcy5nZXRPZmZzZXRGb3JJbmRleChpbmRleCwgaW5pdGlhbEFsaWduKTtcbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRvT2Zmc2V0LCB7IGFkanVzdG1lbnRzOiB2b2lkIDAsIGJlaGF2aW9yIH0pO1xuICAgICAgaWYgKGJlaGF2aW9yICE9PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpICYmIHRoaXMudGFyZ2V0V2luZG93KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IHRoaXMudGFyZ2V0V2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgY29uc3QgZWxlbWVudEluRE9NID0gdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLmhhcyhcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5nZXRJdGVtS2V5KGluZGV4KVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGVsZW1lbnRJbkRPTSkge1xuICAgICAgICAgICAgY29uc3QgW3RvT2Zmc2V0Ml0gPSB0aGlzLmdldE9mZnNldEZvckluZGV4KGluZGV4LCBhbGlnbik7XG4gICAgICAgICAgICBpZiAoIWFwcHJveEVxdWFsKHRvT2Zmc2V0MiwgdGhpcy5zY3JvbGxPZmZzZXQpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChpbmRleCwgeyBhbGlnbiwgYmVoYXZpb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChpbmRleCwgeyBhbGlnbiwgYmVoYXZpb3IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsQnkgPSAoZGVsdGEsIHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXgoKTtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuc2Nyb2xsT2Zmc2V0ICsgZGVsdGEsIHtcbiAgICAgICAgYWRqdXN0bWVudHM6IHZvaWQgMCxcbiAgICAgICAgYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5nZXRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLmdldE1lYXN1cmVtZW50cygpO1xuICAgICAgbGV0IGVuZDtcbiAgICAgIGlmIChtZWFzdXJlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVuZCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nU3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0aGlzLm9wdGlvbnMubGFuZXMgPT09IDEgPyAoKF9hID0gbWVhc3VyZW1lbnRzW21lYXN1cmVtZW50cy5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVuZCkgPz8gMCA6IE1hdGgubWF4KFxuICAgICAgICAgIC4uLm1lYXN1cmVtZW50cy5zbGljZSgtdGhpcy5vcHRpb25zLmxhbmVzKS5tYXAoKG0pID0+IG0uZW5kKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuZCAtIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4gKyB0aGlzLm9wdGlvbnMucGFkZGluZ0VuZDtcbiAgICB9O1xuICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0ID0gKG9mZnNldCwge1xuICAgICAgYWRqdXN0bWVudHMsXG4gICAgICBiZWhhdmlvclxuICAgIH0pID0+IHtcbiAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxUb0ZuKG9mZnNldCwgeyBiZWhhdmlvciwgYWRqdXN0bWVudHMgfSwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucykub25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzLCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0cyk7XG4gICAgdGhpcy5zY3JvbGxSZWN0ID0gdGhpcy5vcHRpb25zLmluaXRpYWxSZWN0O1xuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gdHlwZW9mIHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLm9wdGlvbnMuaW5pdGlhbE9mZnNldCgpIDogdGhpcy5vcHRpb25zLmluaXRpYWxPZmZzZXQ7XG4gICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IHRoaXMub3B0aW9ucy5pbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGU7XG4gICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICB0aGlzLml0ZW1TaXplQ2FjaGUuc2V0KGl0ZW0ua2V5LCBpdGVtLnNpemUpO1xuICAgIH0pO1xuICAgIHRoaXMubm90aWZ5KGZhbHNlLCBmYWxzZSk7XG4gIH1cbn1cbmNvbnN0IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoID0gKGxvdywgaGlnaCwgZ2V0Q3VycmVudFZhbHVlLCB2YWx1ZSkgPT4ge1xuICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICBjb25zdCBtaWRkbGUgPSAobG93ICsgaGlnaCkgLyAyIHwgMDtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBnZXRDdXJyZW50VmFsdWUobWlkZGxlKTtcbiAgICBpZiAoY3VycmVudFZhbHVlIDwgdmFsdWUpIHtcbiAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPiB2YWx1ZSkge1xuICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfVxuICB9XG4gIGlmIChsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGxvdyAtIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVSYW5nZSh7XG4gIG1lYXN1cmVtZW50cyxcbiAgb3V0ZXJTaXplLFxuICBzY3JvbGxPZmZzZXRcbn0pIHtcbiAgY29uc3QgY291bnQgPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcbiAgY29uc3QgZ2V0T2Zmc2V0ID0gKGluZGV4KSA9PiBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0O1xuICBjb25zdCBzdGFydEluZGV4ID0gZmluZE5lYXJlc3RCaW5hcnlTZWFyY2goMCwgY291bnQsIGdldE9mZnNldCwgc2Nyb2xsT2Zmc2V0KTtcbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleDtcbiAgd2hpbGUgKGVuZEluZGV4IDwgY291bnQgJiYgbWVhc3VyZW1lbnRzW2VuZEluZGV4XS5lbmQgPCBzY3JvbGxPZmZzZXQgKyBvdXRlclNpemUpIHtcbiAgICBlbmRJbmRleCsrO1xuICB9XG4gIHJldHVybiB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH07XG59XG5leHBvcnQge1xuICBWaXJ0dWFsaXplcixcbiAgYXBwcm94RXF1YWwsXG4gIGRlYm91bmNlLFxuICBkZWZhdWx0S2V5RXh0cmFjdG9yLFxuICBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IsXG4gIGVsZW1lbnRTY3JvbGwsXG4gIG1lYXN1cmVFbGVtZW50LFxuICBtZW1vLFxuICBub3RVbmRlZmluZWQsXG4gIG9ic2VydmVFbGVtZW50T2Zmc2V0LFxuICBvYnNlcnZlRWxlbWVudFJlY3QsXG4gIG9ic2VydmVXaW5kb3dPZmZzZXQsXG4gIG9ic2VydmVXaW5kb3dSZWN0LFxuICB3aW5kb3dTY3JvbGxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../.yarn/cache/@tanstack-virtual-core-npm-3.5.1-70eec2c077-90f3a316c5.zip/node_modules/@tanstack/virtual-core/dist/esm/index.js\n");

/***/ }),

/***/ "../../.yarn/cache/@tanstack-virtual-core-npm-3.5.1-70eec2c077-90f3a316c5.zip/node_modules/@tanstack/virtual-core/dist/esm/utils.js":
/*!******************************************************************************************************************************************!*\
  !*** ../../.yarn/cache/@tanstack-virtual-core-npm-3.5.1-70eec2c077-90f3a316c5.zip/node_modules/@tanstack/virtual-core/dist/esm/utils.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approxEqual: () => (/* binding */ approxEqual),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   notUndefined: () => (/* binding */ notUndefined)\n/* harmony export */ });\nfunction memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  return () => {\n    var _a, _b, _c, _d;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts)))\n      depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts)))\n      resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  };\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) < 1;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLnlhcm4vY2FjaGUvQHRhbnN0YWNrLXZpcnR1YWwtY29yZS1ucG0tMy41LjEtNzBlZWMyYzA3Ny05MGYzYTMxNmM1LnppcC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUIsR0FBRyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVcsSUFBSSxPQUFPO0FBQ2pFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYmphbmcvZG9jcy8uLi8uLi8ueWFybi9jYWNoZS9AdGFuc3RhY2stdmlydHVhbC1jb3JlLW5wbS0zLjUuMS03MGVlYzJjMDc3LTkwZjNhMzE2YzUuemlwL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2Rpc3QvZXNtL3V0aWxzLmpzP2M5MDEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbWVtbyhnZXREZXBzLCBmbiwgb3B0cykge1xuICBsZXQgZGVwcyA9IG9wdHMuaW5pdGlhbERlcHMgPz8gW107XG4gIGxldCByZXN1bHQ7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGxldCBkZXBUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9hID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0cykpKVxuICAgICAgZGVwVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbmV3RGVwcyA9IGdldERlcHMoKTtcbiAgICBjb25zdCBkZXBzQ2hhbmdlZCA9IG5ld0RlcHMubGVuZ3RoICE9PSBkZXBzLmxlbmd0aCB8fCBuZXdEZXBzLnNvbWUoKGRlcCwgaW5kZXgpID0+IGRlcHNbaW5kZXhdICE9PSBkZXApO1xuICAgIGlmICghZGVwc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlcHMgPSBuZXdEZXBzO1xuICAgIGxldCByZXN1bHRUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9iID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0cykpKVxuICAgICAgcmVzdWx0VGltZSA9IERhdGUubm93KCk7XG4gICAgcmVzdWx0ID0gZm4oLi4ubmV3RGVwcyk7XG4gICAgaWYgKG9wdHMua2V5ICYmICgoX2MgPSBvcHRzLmRlYnVnKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChvcHRzKSkpIHtcbiAgICAgIGNvbnN0IGRlcEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gZGVwVGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgY29uc3QgcmVzdWx0RW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSByZXN1bHRUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICBjb25zdCByZXN1bHRGcHNQZXJjZW50YWdlID0gcmVzdWx0RW5kVGltZSAvIDE2O1xuICAgICAgY29uc3QgcGFkID0gKHN0ciwgbnVtKSA9PiB7XG4gICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAgIHN0ciA9IFwiIFwiICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9O1xuICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICBgJWPij7EgJHtwYWQocmVzdWx0RW5kVGltZSwgNSl9IC8ke3BhZChkZXBFbmRUaW1lLCA1KX0gbXNgLFxuICAgICAgICBgXG4gICAgICAgICAgICBmb250LXNpemU6IC42cmVtO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBjb2xvcjogaHNsKCR7TWF0aC5tYXgoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLm1pbigxMjAgLSAxMjAgKiByZXN1bHRGcHNQZXJjZW50YWdlLCAxMjApXG4gICAgICAgICl9ZGVnIDEwMCUgMzElKTtgLFxuICAgICAgICBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmtleVxuICAgICAgKTtcbiAgICB9XG4gICAgKF9kID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNhbGwob3B0cywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gbm90VW5kZWZpbmVkKHZhbHVlLCBtc2cpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdW5kZWZpbmVkJHttc2cgPyBgOiAke21zZ31gIDogXCJcIn1gKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmNvbnN0IGFwcHJveEVxdWFsID0gKGEsIGIpID0+IE1hdGguYWJzKGEgLSBiKSA8IDE7XG5jb25zdCBkZWJvdW5jZSA9ICh0YXJnZXRXaW5kb3csIGZuLCBtcykgPT4ge1xuICBsZXQgdGltZW91dElkO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHRhcmdldFdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB0aW1lb3V0SWQgPSB0YXJnZXRXaW5kb3cuc2V0VGltZW91dCgoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmdzKSwgbXMpO1xuICB9O1xufTtcbmV4cG9ydCB7XG4gIGFwcHJveEVxdWFsLFxuICBkZWJvdW5jZSxcbiAgbWVtbyxcbiAgbm90VW5kZWZpbmVkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../.yarn/cache/@tanstack-virtual-core-npm-3.5.1-70eec2c077-90f3a316c5.zip/node_modules/@tanstack/virtual-core/dist/esm/utils.js\n");

/***/ })

};
;